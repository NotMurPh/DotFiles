#!/bin/bash

# Simplify managing your VPN
Vpn() (

	name="ip1"
	ip="199.83.103.100"
	
	open_middle_man() {
		if [[ "$3" == "udp2raw" ]]; then
			udp2raw -c -l 0.0.0.0:4444 -r "$ip":2001 --cipher-mode xor --auth-mode simple --raw-mode icmp &> /dev/null &
		else
			forwarder -l 127.0.0.1:4444 -r "$ip":3001 -p passdg &> /dev/null &
		fi
	}

	close_middle_man() {
		if [[ "$3" == "udp2raw" ]]; then
			pkill udp2raw
		else
			pkill forwarder
		fi
	}

	# Process the subcommands
	case "${2,,}" in

		"on")
			wg-quick up "$name" &> /dev/null
			open_middle_man
			sudo -E eww update vpn_status="$name"
		;;

		"off")
			wg-quick down "$name" &> /dev/null
			sudo -E eww update vpn_status=""
		;;

		"reload")
			close_middle_man
			open_middle_man
		;;

		"kill"|"close")
			close_middle_man
		;;

		*)
			echo -e "${bred}Error: Couldn't find the subcommand '$2'!${clear}" || exit 1
		;;

	esac

	echo -e "${bgreen}VPN updated successfully.${clear}"

)

# Manage your direct routes easily
Route() {

	# Define some default variables
	routes=$(ip r)
	interface=$(echo "$routes" | awk 'NR==1 {print $5}')
	gateway=$(echo "$routes" | awk 'NR==1 {print $3}')
	ip="$3"
	name="$4"

	# Check if the user provided the necessary IP address
	if [[ "${2,,}" != "load" && -z "$ip" ]]; then
		echo -e "${bred}Error: You didn't enter the required IP address!${clear}" ; exit 1 
	fi

	# Process the subcommands
	case "${2,,}" in

		"add")
			ip r add "$ip" via "$gateway" dev "$interface"
			if [[ -n "$name" ]]; then echo "$name" "$ip" >> ~/.config/NetScope/Routes; fi
		;;

		"remove"|"delete")
			ip r delete "$ip" via "$gateway" dev "$interface"
			if [[ -n "$name" ]]; then sed -i "/$name $ip/d" ~/.config/NetScope/Routes; fi

		;;

		"load")

			# Get the routes from the config file
			names=($(awk '{print $1}' ~/.config/NetScope/Routes))
			ips=($(awk '{print $2}' ~/.config/NetScope/Routes))

			# Add all of the routes
			for index in $(seq "${#names[@]}");do
				ip r add "${ips[$index-1]}" via "$gateway" dev "$interface" &&
				echo -e "${bgreen}Route ${names[$index-1]} added.${clear}"
			done

			NetScope vpn reload

		;;

		*)
			echo -e "${bred}Error: Couldn't find the subcommand '$2'!${clear}"	
		;;

	esac

	echo "Routes for interface '$interface' updated successfully."

}

# Change between DNS servers easily like a badbakhte irani
Dns() {

	case "${2,,}" in

		"default"|"")
			server1="1.1.1.1"
			server2="8.8.8.8"
		;;

		"electro")
			server1="78.157.42.100"
			server2="78.157.42.101"
		;;

		"shecan")
			server1="178.22.122.100"
			server2="185.51.200.2"
		;;

		"radar")
			server1="10.202.10.10"
			server2="10.202.10.11"
		;;

		*)
			echo -e "${bred}Error: Couldn't find the subcommand '$2'!${clear}"	
		;;

	esac

	# Change the DNS temporarily using the /etc/resolv.conf file
	echo -e "# Generated by ye badbakhte irani \\nnameserver $server1 \\nnameserver $server2" | sudo tee /etc/resolv.conf > /dev/null
	echo -e "# Generated by ye badbakhte irani \\nsupersede domain-name-servers $server1,$server2;" | sudo tee /etc/dhclient.conf > /dev/null

	echo -e "${bgreen}DNS Updated successfully.${clear}"

}

# Cycle through your network interfaces activating one at a time
Cycle() (

	echo "Cycling through network interfaces."

	# Interfaces and their SSIDs to loop through
	interfaces=("Lan" "Phone" "Wifi" "Usb")
	ssids=("M-Murphy" "P-Murphy" "I-Murphy" "S-Murphy")

	# Get the active interface index
	active_interface=$(ip r | awk 'NR==1 {print $5}')
	echo "${interfaces[@]}" | grep -wq "$active_interface" || active_interface="Usb"
	active_interface_index=$(printf "%s\n" "${interfaces[@]}" | grep -n "$active_interface" | cut -d: -f1 | awk '{print $1 - 1}')

	# Loop through the next possible interfaces
	for (( offset=1 ; offset <= 3 ; offset++ )); do

		# Get the index of the next interface in the list
		next_interface_index=$(( ($active_interface_index + offset) % ${#interfaces[@]} ))

		# Make sure that interface exists otherwise use the next one
		ip -br l | grep -q "${interfaces[$next_interface_index]}" && break

	done

	# Cycle to the next available interface
	ip l set "${interfaces[$next_interface_index]}" up || exit 1
	dhclient "${interfaces[$next_interface_index]}" || exit 1
	echo -e "${bgreen}Interface '${interfaces[$next_interface_index]}' Activated.${clear}"

	ip a flush dev "$active_interface"
	pkill -f "dhclient.*$active_interface"
	echo "Interface '$active_interface' Deactivated."

	NetScope route load

	# Updating eww variables to match the current interface
	eww update cycle_btn_class="cycle_btn_class$((next_interface_index + 1))"
	eww update cycle_btn_status_class="cycle_btn_status_class$((next_interface_index + 1))"
	eww update cycle_btn_status="${ssids[$next_interface_index]}"

)

# The function responsible for setting up namespaces
CreateNetNS() {

	# Define some variables
	interface="$1"
	netns="$interface-$(echo $(ip netns | grep $interface | wc -l) + 1 | bc)"

	# Don't run if we're in a namespace
	if [[ -n $(ip netns identify) ]]; then echo -e "${bred}Error: Cannot create a nested network namespace!${clear}" ; return 1 ; fi

	# Check to see if the interface provided actually exists
	if ! ip -br l | grep -Eq "(^| )$interface($| )"; then echo -e "${bred}Error: Interface '$interface' not found!${clear}" ; return 1 ; fi

	# Create the namespace
	ip netns add "$netns"

	# Make the namespace resolv.conf file
	if [[ ! -f /etc/netns/"$netns"/resolv.conf ]]; then
		rm -r /etc/netns/"$netns"
		mkdir -p /etc/netns/"$netns"
		cp /etc/resolv.conf /etc/netns/"$netns"/resolv.conf
	fi

	# Get the interface gateway
	routes=$(ip r)
	if echo "$routes" | grep -q "default.*$interface"; then
		gateway=$(echo "$routes" | grep "default.*$interface" | awk '{print $3}')
	else
		ip l set "$interface" up
		gateway=$(dhclient -v -r "$interface" 2>&1 | grep "DHCPRELEASE" | awk '{print $7}')
	fi

	# Find a free IP address to use
	taken_ips=$(ip -br a ; ip -all netns exec ip -br a)
	for each_subnet in {2..255}; do
		! echo "$taken_ips" | grep -wq "${gateway%.*}.$each_subnet" && ip="${gateway%.*}.$each_subnet" && break
	done

	# Create an ipvlan interface that is linked to the main interface then move it to the created namespace
	ip link add ipvlan link "$interface" type ipvlan mode l2
	ip link set ipvlan netns "$netns"

	# Turning on the namespace interfaces
	ip -n "$netns" link set ipvlan up
	ip -n "$netns" link set lo up

	# Assign the IP address and the default route
	ip -n "$netns" addr add "$ip/24" dev ipvlan
	ip -n "$netns" route add default via "$gateway"

	# Make pinging not require root access
	ip netns exec "$netns" sysctl net.ipv4.ping_group_range='0 2147483647' > /dev/null

	echo -e "${bgreen}Created the namespace '$netns' successfully.${clear}"

}

# The function responsible for removing namespaces
RemoveNetNS() {

	# Define some variables
	netns="$1"

	# Kill all of the processes running in the namespace
	for pid in $(ip netns pids "$netns"); do kill "$pid"; done

	# Remove the namespace and its configs
	ip netns delete "$netns"
	rm -r /etc/netns/"$netns"

	echo -e "${bgreen}NetNS '$netns' removed successfully.${clear}"

}

# Create and manage network namespaces assigned to your interfaces
NetNS() {

	# Get the active interface
	interface=$(ip r | awk 'NR==1 {print $5}')
	if [[ -n "$3" ]]; then interface="$3" ; fi

	# Process the subcommands
	case "${2,,}" in

		"status"|"")

			# Get the ps list for faster processing
			pslist=$(ps -A -o pid=,ppid=,cmd=)

			# Loop through all of the network namespaces
			for netns in $(ip netns | awk '{print $1}'); do

				# Show the netns and it's vpn
				echo -e "$netns $bblue$(ip netns exec "$netns" networkctl 2>/dev/null | awk '/wireguard/ {print "("$2")"}')$clear"

				# Reset some variables
				first=true
				continue=false
				blacklist=()

				# Loop through that netns processes
				for pid in $(ip netns pids "$netns"); do

					# Show processes that have a valid parent ( systemd or SHELL )
					ppid=$(echo "$pslist" | awk "\$1 == $pid { print \$2 }") ; test -z "$ppid" && ppid="0"
					if [[ $ppid -eq 1 ]] || echo "$pslist" | awk "\$1 == $ppid { print \$3 }" | grep -q "$SHELL"; then

						# Skip if process is blacklisted
						for psname in "${blacklist[@]}"; do
							echo "$pslist" | awk "\$1 == $pid { print \$3 }" | grep -q "$psname" && continue=true && break
						done
						if [[ "$continue" = true ]]; then continue ; fi

						# Show the process using a compacted tree format
						echo -n " └───"
						pstree=$(pstree -T -U "$pid")
						if [[ $(echo "$pstree" | wc -l ) -eq 1 ]]; then
							echo "$pstree"
						else
							psname=$(basename "$(echo "$pslist" | awk "\$1 == "$pid" { print substr(\$0, index(\$0,\$3)) }")" | cut -d ' ' -f 1)
							echo "$psname"
							blacklist+=("$psname")
						fi

						# Fix the previous line '└' character if there is one
						if [[ "$first" == false ]]; then
							echo -ne "\033[2A ├\033[2B\r"
						fi
						first=false

					fi
				done

			done

		;;

		"create")
			CreateNetNS "$interface"
		;;

		"delete"|"remove")

			# Target all interfaces if user didn't provide any
			if [[ -z "$3" ]]; then interface="-" ; fi

			# If the name didn't end with -Num then remove all of the instances of that interface otherwise just remove the namespace with the name
			if [[ ! "$interface" =~ -[0-9]+$ ]]; then
				for netns in $(ip netns | grep "$interface" | awk '{print $1}'); do
					RemoveNetNS "$netns"
				done
			else
				RemoveNetNS "$interface"
			fi

		;;

		"exec"|"run")

			# If the name didn't end with -Num create a new netns and exec in that
			if [[ ! "$interface" =~ -[0-9]+$ ]]; then
				CreateNetNS "$interface" || exit 1
				interface="$interface-$(ip netns | grep $interface | wc -l)"
			fi

			# Execute the provided command in the provided namespace
			ip netns exec "$interface" sudo -Esu $(logname) eval "${@:4}"

		;;

		*)
			echo -e "${bred}Error: Couldn't find the subcommand '$2'!${clear}"
		;;

	esac

}

# NetScope NetNS integration for Rofi
Rofi() {

	# Get the interface names
	interfaces=$(ip netns | awk '{print $1}')
	interfaces+="$(echo && networkctl 2>&1 | grep "ether\|wlan" | awk '{print $2}')"

	# If we got an interface use it otherwise show the interfaces
	if [[ -n "$2" ]]; then
		daemon -u $(logname) -D ~ -- sudo -E NetScope NetNS Run "$2" "rofi -show drun"
	else
		echo "$interfaces"
	fi

}

# Define some color variables
clear='\033[0m'
bblue='\033[1;34m'
bgreen='\033[1;32m'
bred='\033[1;31m'

# Make sure we have root access ;)
if [[ $(id -u) -ne 0 ]]; then
	echo -e "${bred}Error: Root access required!, run using sudo -E${clear}" ; exit 1
fi

# Main argument handler
case "${1,,}" in

	"vpn")

		# Only execute commands if we are not executing already
		if [[ "$(ps aux | grep '/NetScope vpn' | grep -v 'grep' | wc -l)" -gt 2 ]]; then
			exit 1
		fi

		Vpn "$@"

	;;

	"route")
		Route "$@"
	;;

	"dns")
		Dns "$@"
	;;

	"cycle")

		# Only execute commands if we are not executing already
		if [[ "$(ps aux | grep '/NetScope cycle' | grep -v 'grep' | wc -l)" -gt 2 ]]; then
			exit 1
		fi

		Cycle "$@"

	;;

	"netns")
		NetNS "$@"
	;;

	"rofi")
		Rofi "$@"
	;;

	*)
		echo -e "${bred}Error: Couldn't find the command '$1'!${clear}"
	;;

esac

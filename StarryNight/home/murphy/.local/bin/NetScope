#!/bin/bash

# Simplify managing your vpn
Vpn() (

	name="l-hetzner1-1"
	ip="199.83.103.100"
	
	open_middle_man() {
		if [ "$3" == "udp2raw" ]; then
			udp2raw -c -l 0.0.0.0:4444 -r "$ip":2001 --cipher-mode xor --auth-mode simple --raw-mode icmp &> /dev/null &
		else
			forwarder -l 127.0.0.1:4444 -r "$ip":3001 -p passdg &> /dev/null &
		fi
	}

	close_middle_man() {
		if [ "$3" == "udp2raw" ]; then
			pkill udp2raw
		else
			pkill forwarder
		fi
	}

	# Prosses the subcommands
	case "${2,,}" in

		"on")
			wg-quick up "$name" &> /dev/null
			open_middle_man
			sudo -E eww update vpn_status="wireguard"
		;;

		"off")
			wg-quick down "$name" &> /dev/null
			sudo -E eww update vpn_status=""
		;;

		"reload")
			close_middle_man
			open_middle_man
		;;

		"kill"|"close")
			close_middle_man
		;;

		*)
			echo "Error: Couldn't find the subcommand $2"	
		;;

	esac

)

# Manage your direct routes easily
Route() {

	# Define some default variables
	routes=$(ip r)
	interface=$(echo "$routes" | awk 'NR==1 {print $5}')
	gateway=$(echo "$routes" | awk 'NR==1 {print $3}')
	ip="$3"

	# Check if the user provided the necessary ip address
	if [[ "${2,,}" != "load" && -z "$ip" ]]; then
		echo "Error: You didn't enter the required ip address!" ; exit 1 
	fi

	# Prosses the subcommands
	case "${2,,}" in

		"add")
			ip r add "$ip" via "$gateway" dev "$interface"
		;;

		"remove"|"delete")
			ip r delete "$ip" via "$gateway" dev "$interface"
		;;

		"load")

			# Get the routes from the config file
			names=($(awk '{print $1}' ~/.config/NetScope/Routes))
			ips=($(awk '{print $2}' ~/.config/NetScope/Routes))

			# Add all of the routes
			for index in $(seq "${#names[@]}");do
				ip r add "${ips[$index-1]}" via "$gateway" dev "$interface" &&
				echo "Route ${names[$index-1]} added!"
			done

		;;

		*)
			echo "Error: Couldn't find the subcommand $2"
		;;

	esac

	echo "Routes for $interface updated successfully"

}

# Change between dns servers easily like a badbakhte irani
Dns() {

	case "${2,,}" in

		"default"|"")
			server1="1.1.1.1"
			server2="8.8.8.8"
		;;

		"electro")
			server1="78.157.42.100"
			server2="78.157.42.101"
		;;

		"shecan")
			server1="178.22.122.100"
			server2="185.51.200.2"
		;;

		*)
			echo "Error: Couldn't find the subcommand $2"	
		;;

	esac

	# Change the dns temporarily using the /etc/resolv.conf file
	echo -e "# Generated by ye badbakhte irani \\nnameserver $server1 \\nnameserver $server2" | sudo tee /etc/resolv.conf > /dev/null
	echo -e "# Generated by ye badbakhte irani \\nsupersede domain-name-servers $server1,$server2;" | sudo tee /etc/dhclient.conf > /dev/null

	echo "DNS Updated successfully"

}

# Cycle through your network interfaces activating one at a time
Cycle() (

	echo "Cycling through network interfaces!"

	# Interfaces and their ssids to loop through
	interfaces=("enp6s0" "enp0s20f0u1" "wlp0s20f0u10" "enp0s20f0u6u1")
	ssids=("M-Murphy" "P-Murphy" "I-Murphy" "S-Murphy")

	# Get the active interface index
	active_interface=$(ip r | awk 'NR==1 {print $5}')
	echo "${interfaces[@]}" | grep -q "$active_interface" || active_interface="enp0s20f0u6u1"
	active_interface_index=$(printf "%s\n" "${interfaces[@]}" | grep -n "$active_interface" | cut -d: -f1 | awk '{print $1 - 1}')

	# loop through the next possible interfaces
	for (( offset=1 ; offset <= 3 ; offset++ )); do

		# Get the index of the next interface in the list
		next_interface_index=$(( ($active_interface_index + offset) % ${#interfaces[@]} ))

		# Make sure that interface exists otherwise use the next one
		ip -br l | grep -q "${interfaces[$next_interface_index]}" && break

	done

	# Cycle to the next available interface
	dhclient -x &> /dev/null
	dhclient "${interfaces[$next_interface_index]}" || exit 1
	echo "Interface ${interfaces[$next_interface_index]} Activated!"
	ip r flush dev "$active_interface"
	echo "Interface $active_interface Deactivated!"
	NetScope route load
	NetScope vpn reload

	# Updateing eww variables to match the current interface
	eww update cycle_btn_class="cycle_btn_class$((next_interface_index + 1))"
	eww update cycle_btn_status_class="cycle_btn_status_class$((next_interface_index + 1))"
	eww update cycle_btn_status="${ssids[$next_interface_index]}"

)

# The function responsable for setting up namespaces
CreateNetNS() {

	# Define some variables
	interface="$1"
	name="$interface-$(echo $(ip netns | grep $interface | wc -l) + 1 | bc)"

	# Don't run if we're in a namespace
	if [[ -n $(ip netns identify) ]]; then echo "Error: Cannot create a nested network namespace!" ; return 1 ; fi

	# Check to see if the interface provided actually exists
	if ! ip -br l | grep -Eq "(^| )$interface($| )"; then echo "Error: Interface not found!" ; return 1 ; fi

	# Create the namespace
	ip netns add "$name"

	# Make the namespace resolv.conf file
	if [ ! -f /etc/netns/"$name"/resolv.conf ]; then
		mkdir -p /etc/netns/"$name"
		cp /etc/resolv.conf /etc/netns/"$name"/resolv.conf
	fi

	# Get the interface gateway
	routes=$(ip r)
	if echo "$routes" | grep -q "default.*$interface"; then
		gateway=$(echo "$routes" | grep "default.*$interface" | awk '{print $3}')
	else
		gateway=$(dhclient -v -r "$interface" 2>&1 | grep "DHCPRELEASE" | awk '{print $7}')
	fi

	# Find a free ip address to use
	taken_ips=$(ip -br a ; ip -all netns exec ip -br a)
	for each_subnet in {2..255}; do
		! echo "$taken_ips" | grep -wq "${gateway%.*}.$each_subnet" && ip="${gateway%.*}.$each_subnet" && break
	done

	# Create an ipvlan interface that is linked to the main interface then move it to the created namespace
	ip link add ipvlan link "$interface" type ipvlan mode l2
	ip link set ipvlan netns "$name"

	# Turning on the namespace interfaces
	ip -n "$name" link set ipvlan up
	ip -n "$name" link set lo up

	# Assign the ip address and the default route
	ip -n "$name" addr add "$ip/24" dev ipvlan
	ip -n "$name" route add default via "$gateway"

	# Make pinging don't require root access
	ip netns exec "$name" sysctl net.ipv4.ping_group_range='0 2147483647' > /dev/null

	echo "Succesfuly created the namespace $name!"

}

# The function responsable for removing namespaces
RemoveNetNS() {

	# Define some variables
	interface="$1"

	# Kill all off the prosses running in the namespace
	for pid in $(ip netns pids "$interface"); do kill "$pid"; done

	# Remove the namespace and it's configs
	ip netns delete "$interface"
	rm -r /etc/netns/"$interface"

	echo "NetNS $netns removed successfully!"

}

# Create and manage network namespaces assigned to your interfaces
NetNS() {

	# Get the active interface
	interface=$(ip r | awk 'NR==1 {print $5}')
	if [ -n "$3" ]; then interface="$3" ; fi

	# Prosses the subcommands
	case "${2,,}" in

		"status"|"")
			ip netns
		;;

		"create")
			CreateNetNS "$interface"
		;;

		"delete"|"remove")

			# Target all interfaces if user didn't provide any
			if [ -z "$3" ]; then interface="-" ; fi

			# If the name didn't end with -Num then remove all of the instances of that interface otherwise just remove the namespace with the name
			if [[ ! "$interface" =~ -[0-9]+$ ]]; then
				for netns in $(ip netns | grep "$interface" | awk '{print $1}'); do
					RemoveNetNS "$netns"
				done
			else
				RemoveNetNS "$interface"
			fi

		;;

		"exec"|"run")

			# If the name didn't end with -Num create a new netns and exec in that
			if [[ ! "$interface" =~ -[0-9]+$ ]]; then
				CreateNetNS "$interface" || exit 1
				interface="$interface-$(ip netns | grep $interface | wc -l)"
			fi

			# Execute the provided command in the provided namespace
			ip netns exec "$interface" sudo -Esu $(logname) eval "${@:4}"

		;;

		*)
			echo "Error: Couldn't find the subcommand $2"
		;;

	esac

}

# NetScope NetNS integration for Rofi
Rofi() {

	# Get the inerface names
	interfaces=$(ip netns | awk '{print $1}')
	interfaces+="$(echo && networkctl | grep "ether\|wlan" | awk '{print $2}')"

	# If we got an interface use it otherwise show the interfaces
	if [ -n "$2" ]; then
		daemon -u $(logname) -D ~ -- sudo -E NetScope NetNS Run "$2" "rofi -show drun"
	else
		echo "$interfaces"
	fi

}

# Make sure we have root access ;)
if [ $(id -u) -ne 0 ]; then
	echo "Error: Root access required!, run using sudo -E" ; exit 1
fi

# Main argument handler
case "${1,,}" in

	"vpn")

		# Only execute commands if we are not executing already
		if [[ "$(ps aux | grep 'Ss' | grep 'NetScope vpn' | grep -v 'grep' | wc -l)" -gt 1 ]]; then
			exit 1
		fi

		Vpn "$@"

	;;

	"route")
		Route "$@"
	;;

	"dns")
		Dns "$@"
	;;

	"cycle")

		# Only execute commands if we are not executing already
		if [[ "$(ps aux | grep 'Ss' | grep 'NetScope cycle' | grep -v 'grep' | wc -l)" -gt 1 ]]; then
			exit 1
		fi

		Cycle "$@"

	;;

	"netns")
		NetNS "$@"
	;;

	"rofi")
		Rofi "$@"
	;;

	*)
		echo "Error: Couldn't find command $1"
	;;

esac
